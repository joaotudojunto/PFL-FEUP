% Aula pratica 2 - Recursividade e listas 

:-use_module(library(lists)).

fatorial(0,1).
fatorial(N,F) :- N > 0,
                 N1 is N -1, 
                 fatorial(N1, F1),
                 F is F1 * N. 

somaRec(0, 0).
somaRec(N, Sum) :- N > 0,            % N tem de ser sempre superior a 0 para somar
                   N1 is N-1,        % N tem de decrescer 
                   somaRec(N1, Sum1),   
                   Sum is Sum1 + N. 

/* 
The sequence follows the rule that each number is equal to the sum of the preceding two numbers. 
The Fibonacci sequence begins with the following 14 integers: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
The Fibonacci numbers are generated by setting F0 = 0, F1 = 1, and then using the recursive formula. Fn = Fn-1 + Fn-2. to get the rest
*/

fibonacci(N, F) :-  N = 0, F = 0;
                    N = 1, F = 1;
                    N > 1, N1 is N-1, N2 is N-2, % 1 Numero antes (N1), e dois numeros antes (N2)
                    fibonacci(N1, F1), 
                    fibonacci(N2, F2), 
                    F is F1 + F2.

% d) Numero primo 

divisible(X,Y) :- 0 is X mod Y.
divisible(X,Y) :- Y < X - 1,
                  Y1 is Y+1,
                  divisible(X, Y1).

isPrime(2).
isPrime(X) :- X > 1, 
              \+divisible(X, 2).


% exercicio 2 

ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
descendent(X, Y) :- ancestor(Y, X).

% exercicio 3

superior(X, Y) :- chefiado_por(Y, X).

% exercicio 4
/*
 a) yes 
 b) error 
 c) error 
 d) H = pfl  e T = restantes 
 e) H = lbaw, e T = ltw 
 f) H = leic e T = [] 
 g) no 
 h) h = leic, e tail o resto 
 i) h = leic, e tail [two] 
 j) Inst = gram, e LEIC = feup 
 k) One = 1, Two = 2 e tail = 3,4
 l) one = leic, Rest = [two, tail]

*/

member1(X, [X|_]).
member1( X, [_|T]) :- member1(X, T).

memberchk1(X, [X|_]).
memberchk1(X, [Y|T]) :- X \= Y, memberchk1(X,T).  

append1( [], L2, L2).
append1( [H|T], L2, [H|L3]) :- append1(T, L2, L3). % [1,2] ++ [3,4] = Head|L3 que é [1] + [], e L3 passa a ser Tail de L1 [2] ++ L2 = [2] ++ [3,4] = [1,2,3,4].


% exercicio 5

list_size([], 0).
list_size([_ | Tail], N) :- list_size(Tail, N1), N is N1 + 1.

list_sum([], 0).
list_sum([Head | Tail], Sum) :- list_sum(Tail, Sum1), Sum is Sum1 + Head.

list_prod([], 1).
list_prod([Head | Tail], Mult) :- list_prod(Tail, Mult1), Mult is Mult1 * Head.

inner_product([], [], 0).
inner_product([Head1 | Tail1], [Head2 | Tail2], Sum) :- inner_product(Tail1, Tail2, Sum1), Sum is Sum1 + Head1 * Head2.

% count (X, [], 0).
% count(X, [Head | Tail], N) :- X = Head, count(X, Tail, N1), N is N1 + 1.


% Exercicio 6 

%a
invert(L1, L2) :- reverse(L1, [], L2). 
reverse([], L, L).
reverse([Head | Tail], Acc, L) :- reverse(Tail, [Head | Acc], L).

%b
del_one(X, [X], []). 
del_one(X, [ X | Tail], Tail).
del_one(X, [Head | Tail], [Head | Tail1]) :- del_one(X, Tail, Tail1). % del_one(1, [1,2,3], Newlist).

%c
del_all(X, [X], []).
del_all(X, [X | Tail], Lista) :- del_all(X, Tail, Lista).                              
del_all(X, [Head | Tail], [Head | Lista]) :- del_all(X, Tail, Lista).

%d
del_all_list([], L, L).
del_all_list([H | T], List1, List2) :- del_all(H, List1, L),
                                       del_all_list(T, L, List2).

%e
del_dups([], []).
del_dups([H | T], [H | R]) :- member(H, T), 
                              del_all(H, T, L),
                              del_dups(L, R).

del_dups([H | T], [H | R]) :- del_dups(T, R).

%g
replicate(0, _, []).
replicate(Amount, X, [X | Tail]) :- Amount > 0, Amount1 is Amount - 1, replicate(Amount1, X, Tail).

%h
intersperse(_, [], []).
intersperse(X, [Head | Tail], [Head, X | Tail1]) :- intersperse(X, Tail, Tail1).


%Exercicio 7 
%a
list_append([], L, L).
list_append([Head | Tail], L, [Head | Tail1]) :- list_append(Tail, L, Tail1).

%b 
list_member(Elem, [Elem | _ ] ). 
list_member(Elem, [ _ | Tail]) :- list_member(Elem, Tail). 

%c 
list_last( [Last | []], Last).
list_last([_ | Tail], Last) :- list_last(Tail, Last).

%Exercicio 8

%b 
list_from_to(Inf, Sup, [Inf | Tail]) :- Inf < Sup,
                                        Inf1 is Inf +1,  %Se inf é 2, então o proximo inf é 3, enquanto for < que Sup.. 
                                        list_from_to(Inf1, Sup, Tail).
list_from_to(Sup, Sup, [Sup]).



